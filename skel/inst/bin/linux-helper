#!/bin/bash

## ssh-helper: Helper for the SSH cluster functions of the BatchJobs R
##   package.
##
## Requires the following Unix command line utilities:
##
##  * grep, ps, kill, xargs, awk
##
## The following commands are implemented. Each command returns output
## which should be valid R code, which once evaluated creates a
## suitable R representation of the commands result.
##
## number-of-processors
##  Return the number of PEs on worker.
##
## worker-status FILEDIR
##   Return status of worker. The following list is defined
##     load: 3 real numbers, the load averave of the last 5,10,15 minutes
##     running_r_processes: number of R processes on this node of all users, 
##       no further restrictions
##     running_r_processes_50: number of R processes on this node of all users, 
##       that have more than 50 percent cpu usage when queried with 'ps -o pcpu'
##     running_batch_jobs: number of batch jobs, generated by BatchJobs for this 
##       this registry. The heuristic is: R processes for this user that have 
##       '-f $FILEDIR/jobs' in 'ps -o cmd'.  
##   number of running R jobs.
##
## start-job RFILE OUTFILE
##   Start an R CMD BATCH process running $RFILE and log
##   the output in $OUTFILE.
##
## kill-job PID
##   Kill the R job with PID $PID.
##   First a TERM is sent, then 1 sec delay, then KILL. 
##
## list-jobs FILEDIR
##   Lists the pids of all jobs for this registry.
##
## All other commands will return a stop() condition to R.
##

RHOME="$1"; shift
CMD="$1"; shift
LC_ALL=C ## Avoid any localization issues.

if [ -n "$RHOME" ]; then
    RCMD="$RHOME/bin/R"
else
    RCMD="R"
fi


case $CMD in
    number-of-cpus)
        cat /proc/cpuinfo | grep '^processor' | wc -l
        ;;
    worker-status)
        LOAD=uptime | awk '{print $8}'
        JOBDIR="$1/jobs"
        # we count all R processes, all R50, and all where JOBDIR was in the call args
        # use ww for unlimited width in ps for cmd output
        # use our own field sep, so we can take it apart with awk and dont get bothered by whitespaces
        NJOBS=$(ps -ww -o "%p|%C|%a" -C R | \
          awk -v j=$JOBDIR \
          'BEGIN {FS="|";njobs1=0;njobs2=0} 
          $2 > 50.0 {njobs1++} 
          $3 ~ /j/ {njobs2++} 
          END {print NR, njobs1, njobs2}')
        # convert to array  
        NJOBS=($NJOBS)  
        printf "list(\n"
        printf "  load=%f,\n" $LOAD
        printf "  running_r_processes=%i,\n" ${NJOBS[0]}
        printf "  running_r_processes_50=%i,\n" ${NJOBS[1]}
        printf "  running_batch_jobs=%i\n" ${NJOBS[2]}
        printf ")\n"
        ;;
    start-job)
         # nothing should be on all 3 streams except maybe a segfault. throw away. 
         # see comment also in cfLocal
        "$RCMD" CMD BATCH --no-save --no-restore "$1" "$2" \
            > /dev/null 2> /dev/null < /dev/null &
        printf '%i\n' $!
        ;;
    kill-job)
        ps -o pid --ppid $1 --no-heading | xargs kill -TERM > /dev/null 2> /dev/null
        sleep 1
        ps -o pid --ppid $1 --no-heading | xargs kill -KILL > /dev/null 2> /dev/null
        exit 0
        ;;
    list-jobs)
        JOBDIR="$1/jobs"
        # use ww for unlimited width in ps for cmd output
        # use our own field sep, so we can take it apart with awk and dont get bothered by whitespace
        PIDS=$(ps -ww -o "%p|%a" -C R | awk -v j=$JOBDIR 'BEGIN {FS="|"} $2 ~ /j/ {print $1}')
        printf "as.character(c("
        for pid in $PIDS ; do
            printf "%i, " $pid
        done
        # include NULL so last comma is ok, NULL then gets stripped in Reval
        printf "NULL))\n"
        ;;
    *)
        printf "stop(\"Unknown ssh-helper command '%s'.\")\n" $CMD
esac
